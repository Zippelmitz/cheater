#!/usr/bin/env perl

use 5.010001;
use strict;
use warnings;

use lib 'lib';
use Cheater::AST;
use Smart::Comments '####';
use Data::Random qw( rand_chars );
use JSON::XS;
use Getopt::Std;
use Cheater::Parser;

srand(0);

our $OutDir = './tables';

my %opts;
getopts('o:', \%opts) or
    die "Usage: $0 [-o <outfile>] <infile>\n";

#$::RD_HINT = 1;
#$::RD_TRACE = 1;

sub gen_goal ($);
sub gen_column ($$);

sub pick_elems ($$);

sub gen_int_col ($$);
sub gen_num_col ($$);
sub gen_txt_col ($$);
sub gen_custom_type_col ($$$);

my $infile = shift or
    die "No input file specified.\n";

my $parser = Cheater::Parser->new;

open my $in, $infile or
    die "Cannot open $infile for reading: $!\n";

my $src = do { local $/; <$in> };

close $in;

my $parse_tree = $parser->spec($src);

if (!defined $parse_tree) {
    die "Failed to parse $infile due to grammatic errors\n";
}

my $ast = Cheater::AST->new($parse_tree)
    or die "Cannot construct the AST";

my %goals = %{ $ast->{goals} };
my %cols = %{ $ast->{cols} };
my %samples = %{ $ast->{samples} };
my %deps = %{ $ast->{deps} };
my %types = %{ $ast->{types} };
my %tables = %{ $ast->{tables} };

my %cols_visited;

for my $goal (sort keys %goals) {
    my $table = gen_goal($goal);
    #### $table
}

if (! -d $OutDir) {
    mkdir $OutDir or
        die "Failed to create directory \"$OutDir\": $!\n";
}

chdir $OutDir;

sub gen_goal ($) {
    my $table = shift;
    my $rows = $goals{$table};

    my @cols_data;
    my $tb_spec = $tables{$table} or
        die "Cannot found table $table.\n";
    for my $col (@$tb_spec) {
        #say "col: ", $col->[0];
        my $name = $col->[0];
        push @cols_data, gen_column($table, $name);
    }

    return \@cols_data;
}

sub gen_column ($$) {
    my ($table, $col_name) = @_;

    #### $col_name
    my $qcol = "$table.$col_name";

    if (defined $samples{$qcol}) {
        return $samples{$qcol};
    }

    if (my $dep = $cols_visited{$qcol}) {
        die "ERROR: Found circular column references: $qcol references $dep but $dep somehow depends on $qcol.\n";
    }

    my $rows = $goals{$table};

    if (my $dep = $deps{$qcol}) {
        $cols_visited{$qcol} = $dep;
        my ($dep_table, $dep_col_name) = split /\./, $dep, 2;
        if (! $cols{$dep}) {
            die "ERROR: Column $qcol references non-existent column $dep.\n";
        }
        my $refs_data = gen_column($dep_table, $dep_col_name);
        return pick_elems($refs_data, $rows);
    }

    my $spec = $cols{$qcol} or
        die "Column spec not found for $qcol\n";
    #### $spec
    my $type = $spec->{type} or
        die "Type not found for $qcol";

    my $attrs = $spec->{attrs};

    given ($type) {
        when ('text') {
            my $data = gen_txt_col($attrs, $rows);
            $samples{$qcol} = $data;
            return $data;
        }
        when ('integer') {
            my $data = gen_int_col($attrs, $rows);
            $samples{$qcol} = $data;
            return $data;
        }
        when ('serial') {
            push @$attrs, 'serial';
            my $data = gen_int_col($attrs, $rows);
            $samples{$qcol} = $data;
            return $data;
        }
        when ('number') {
            my $data = gen_num_col($attrs, $rows);
            $samples{$qcol} = $data;
            return $data;
        }
        default {
            my $type_def = $types{$type};
            if (! $type_def) {
                die "Type $type not defined for table $table column $col_name.\n";
            }

            my $data = gen_custom_type_col($attrs, $type_def, $rows);
            $samples{$qcol} = $data;
            return $data;
        }
    }
}

sub pick_elems ($$) {
    my ($set, $m) = @_;
    my $n = @$set;
    my @res;
    for (1..$m) {
        my $i = int rand $n;
        push @res, $set->[$i];
    }
    return \@res;
}

sub gen_int ($) {
    my $unsigned = shift;
    return $unsigned ? (int rand 1_000_000) :
        (int rand 1_000_000) - 500_000;
}

sub gen_int_col ($$) {
    my ($attrs, $n) = @_;

    my ($unique, $sort, $not_null, $unsigned);

    for (@$attrs) {
        if ($_ eq 'serial') {
            $unique = 1;
            $sort = 1;
            $not_null = 1;
            $unsigned = 1;
        }

        if ($_ eq 'not null') {
            $not_null = 1;
        }

        if ($_ eq 'unique') {
            $unique = 1;
        }

        if ($_ eq 'unsigned') {
            $unsigned = 1;
        }
    }

    my @nums;
    my %hist;
    for (1..$n) {
        if ($unique) {
            while (1) {
                my $gen_null;
                if (!$not_null) {
                    $gen_null = (int rand 10) == 0;
                    if ($gen_null) {
                        push @nums, undef;
                    }
                }
                if (!$gen_null) {
                    my $num = gen_int($unsigned);
                    if (! $hist{$num}) {
                        push @nums, $num;
                        $hist{$num} = 1;
                        last;
                    }
                }
            }
            next;
        }

        my $gen_null;
        if (!$not_null) {
            $gen_null = (int rand 10) == 0;
            if ($gen_null) {
                push @nums, undef;
            }
        }

        if (! $gen_null) {
            my $num = gen_int($unsigned);
            push @nums, $num;
        }
    }

    if ($sort) {
        @nums = sort @nums;
    }

    return \@nums;
}

sub gen_num_col ($$) {
    my ($attrs, $n) = @_;
}

sub gen_txt_col ($$) {
    my ($attrs, $n) = @_;

    my ($unique, $sort, $not_null);

    for (@$attrs) {
        if ($_ eq 'not null') {
            $not_null = 1;
        }

        if ($_ eq 'unique') {
            $unique = 1;
        }
    }

    my @txts;
    my %hist;
    for (1..$n) {
        if ($unique) {
            while (1) {
                my $gen_null;
                if (!$not_null) {
                    $gen_null = (int rand 10) == 0;
                    if ($gen_null) {
                        push @txts, undef;
                    }
                }
                if (!$gen_null) {
                    my $txt = join '',
                        rand_chars( set => 'all', min => 5, max => 16 );
                    if (! $hist{$txt}) {
                        push @txts, $txt;
                        $hist{$txt} = 1;
                        last;
                    }
                }
            }
            next;
        }

        my $gen_null;
        if (!$not_null) {
            $gen_null = (int rand 10) == 0;
            if ($gen_null) {
                push @txts, undef;
            }
        }

        if (! $gen_null) {
            my $txt = join '',
                rand_chars( set => 'all', min => 5, max => 16 );
            push @txts, $txt;
        }
    }

    return \@txts;
}

sub gen_custom_type_col ($$$) {
}

